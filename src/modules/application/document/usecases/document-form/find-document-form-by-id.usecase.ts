import { ForbiddenException, Injectable, NotFoundException } from '@nestjs/common';
import { DomainDocumentFormService } from '../../../../domain/document-form/document-form.service';
import { DocumentFormResponseDto } from '../../dtos/document-form.dto';
import { Employee } from 'src/database/entities/employee.entity';
import { AutoFillType, ApprovalStepType } from 'src/common/enums/approval.enum';
import { DataSource } from 'typeorm';
import { FormApprovalStep } from 'src/database/entities/form-approval-step.entity';
import { DomainFormApprovalStepService } from 'src/modules/domain/form-approval-step/form-approval-step.service';
import { DomainDepartmentService } from 'src/modules/domain/department/department.service';
import { DomainEmployeeService } from 'src/modules/domain/employee/employee.service';

@Injectable()
export class FindDocumentFormByIdUseCase {
    constructor(
        private readonly documentFormService: DomainDocumentFormService,
        private readonly formApprovalStepService: DomainFormApprovalStepService,
        private readonly departmentService: DomainDepartmentService,
        private readonly employeeService: DomainEmployeeService,
        private readonly dataSource: DataSource,
    ) {}

    async execute(documentFormId: string, user: Employee): Promise<DocumentFormResponseDto> {
        const documentForm = await this.documentFormService.findOne({
            where: { documentFormId },
            relations: [
                'documentType',
                'formApprovalLine',
                'formApprovalLine.formApprovalSteps',
                'formApprovalLine.formApprovalSteps.defaultApprover',
                'formApprovalLine.formApprovalSteps.defaultApprover.departmentPositions',
                'formApprovalLine.formApprovalSteps.defaultApprover.departmentPositions.department',
                'formApprovalLine.formApprovalSteps.defaultApprover.departmentPositions.position',
                'formApprovalLine.formApprovalSteps.defaultApprover.currentRank',
            ],
        });

        if (!documentForm) {
            throw new NotFoundException('문서 양식을 찾을 수 없습니다.');
        }

        // 결재선이 있는 경우 그대로 반환
        if (documentForm.autoFillType === AutoFillType.APPROVAL_LINE) {
            return {
                documentFormId: documentForm.documentFormId,
                name: documentForm.name,
                description: documentForm.description,
                template: documentForm.template,
                autoFillType: documentForm.autoFillType,
                documentType: documentForm.documentType,
                formApprovalLine: documentForm.formApprovalLine,
            };
        }

        // 자동 생성 결재 단계
        // 유저 정보를 관계 데이터와 함께 조회
        const userWithRelations = await this.employeeService.findOne({
            where: { id: user.id },
            relations: [
                'departmentPositions',
                'departmentPositions.department',
                'departmentPositions.position',
                'currentRank',
            ],
        });

        if (!userWithRelations) {
            throw new NotFoundException('사용자 정보를 찾을 수 없습니다.');
        }

        const autoApprovalSteps = await this.generateAutoApprovalSteps(userWithRelations, documentForm.autoFillType);

        // FormApprovalStep을 FormApprovalStepResponseDto로 매핑
        const autoGeneratedSteps = autoApprovalSteps.map((step) => {
            const primaryDeptPosition = step.defaultApprover.departmentPositions?.[0];
            return {
                formApprovalStepId: step.formApprovalStepId,
                type: step.type,
                order: step.order,
                defaultApprover: {
                    employeeId: step.defaultApprover.id,
                    name: step.defaultApprover.name,
                    employeeNumber: step.defaultApprover.employeeNumber,
                    email: step.defaultApprover.email,
                    department: primaryDeptPosition?.department?.departmentCode || '',
                    position: primaryDeptPosition?.position?.positionTitle || '',
                    rank: step.defaultApprover.currentRank?.rankTitle || '',
                },
            };
        });

        return {
            documentFormId: documentForm.documentFormId,
            name: documentForm.name,
            description: documentForm.description,
            template: documentForm.template,
            autoFillType: documentForm.autoFillType,
            documentType: documentForm.documentType,
            autoGeneratedSteps: autoGeneratedSteps,
        };
    }

    private async generateAutoApprovalSteps(user: Employee, autoFillType: AutoFillType) {
        const autoApprovalSteps = [];

        // 유저의 부서-직책 정보 확인
        if (!user.departmentPositions || user.departmentPositions.length === 0) {
            throw new ForbiddenException('사용자의 부서 정보가 없습니다.');
        }

        const primaryDeptPosition = user.departmentPositions[0];

        // Position 정보 확인
        if (!primaryDeptPosition.position) {
            throw new ForbiddenException('사용자의 직책 정보가 없습니다.');
        }

        const newApprovalStep = await this.formApprovalStepService.create({
            type: ApprovalStepType.APPROVAL,
            order: autoApprovalSteps.length + 1,
            defaultApprover: user,
        });

        // 기안자 본인만 추가
        autoApprovalSteps.push(newApprovalStep);
        if (autoFillType === AutoFillType.DRAFTER_SUPERIOR) {
            // 본인을 포함한 상급자들 추가
            const superiors = await this.findSuperiorsByDepartment(
                primaryDeptPosition.departmentId,
                user.id,
                primaryDeptPosition.position.level, // level 사용 (낮을수록 상위 직책)
            );

            // 상급자들을 순서대로 추가
            for (let index = 0; index < superiors.length; index++) {
                const superior = superiors[index];
                const newApprovalStep = await this.formApprovalStepService.create({
                    type: ApprovalStepType.APPROVAL,
                    order: autoApprovalSteps.length + 1,
                    defaultApprover: superior,
                });
                autoApprovalSteps.push(newApprovalStep);
            }
        }

        return autoApprovalSteps;
    }

    private async findSuperiorsByDepartment(
        departmentId: string,
        currentUserId: string,
        currentUserPositionLevel: number,
    ): Promise<Employee[]> {
        // Position의 level이 낮을수록 상위 직책이므로
        // 현재 사용자보다 level이 낮은 직책을 가진 사람들이 상급자
        if (currentUserPositionLevel <= 1) {
            // 이미 최상위 직책인 경우 상급자가 없음
            return [];
        }

        // 현재 부서부터 상위 부서까지 순서대로 flat하게 만들기
        const departmentHierarchy = await this.getDepartmentHierarchy(departmentId);

        // 각 부서에서 상급자 찾기
        const superiors = await this.findSuperiorsInHierarchy(
            departmentHierarchy,
            currentUserId,
            currentUserPositionLevel,
        );
        return superiors;
    }

    private async getDepartmentHierarchy(departmentId: string): Promise<string[]> {
        const hierarchy: string[] = [departmentId];

        // 재귀적으로 상위 부서들을 찾기
        const findUpperDepts = async (deptId: string) => {
            const dept = await this.departmentService.findOne({
                where: { id: deptId },
            });

            if (dept && dept.parentDepartmentId) {
                const parentDept = await this.departmentService.findOne({
                    where: { id: dept.parentDepartmentId },
                });

                if (parentDept) {
                    hierarchy.push(parentDept.id);
                    await findUpperDepts(parentDept.id); // departmentCode → id로 수정
                }
            }
        };

        await findUpperDepts(departmentId);
        return hierarchy;
    }

    private async findSuperiorsInHierarchy(
        departmentHierarchy: string[],
        currentUserId: string,
        currentUserPositionLevel: number,
    ): Promise<Employee[]> {
        const superiors: Employee[] = [];

        // 각 부서를 순서대로 돌면서 상급자 찾기
        for (const dept of departmentHierarchy) {
            // Position의 level이 낮을수록 상위 직책
            const deptSuperiors = await this.dataSource
                .getRepository(Employee)
                .createQueryBuilder('employee')
                .leftJoinAndSelect('employee.departmentPositions', 'departmentPositions')
                .leftJoinAndSelect('departmentPositions.department', 'department')
                .leftJoinAndSelect('departmentPositions.position', 'position')
                .leftJoinAndSelect('employee.currentRank', 'currentRank')
                .where('departmentPositions.departmentId = :department', { department: dept })
                .andWhere('employee.id != :currentUserId', { currentUserId })
                .andWhere('position.level < :currentUserPositionLevel', { currentUserPositionLevel }) // level이 낮을수록 상위
                .orderBy('position.level', 'ASC') // level이 낮은 순서대로 (상위 직책부터)
                .getMany();

            superiors.push(...deptSuperiors);
        }

        return superiors;
    }
}
